{"version":3,"file":"index.js","mappings":";;;;;;;;;AAAA,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,iEAA8B;AAC1C,YAAY,mBAAO,CAAC,uFAAO;AAC3B,UAAU,qDAAuB;AACjC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;;AAEA,UAAU,+HAAmC;AAC7C,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;;AAEf;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,qBAAqB;AAC3B;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,eAAe;AACf,cAAc;AACd,eAAe;AACf,qHAAgC;;AAEhC;AACA;AACA;;AAEA,aAAa;AACb,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA,EAAE,aAAa;AACf,EAAE,aAAa;AACf;AACA;AACA,kBAAkB,SAAS;AAC3B,6BAA6B;AAC7B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;AC7LA;AACA;AACA;AACA;;AAEA;AACA,EAAE,sIAAwC;AAC1C,EAAE;AACF,EAAE,gIAAqC;AACvC;;;;;;;;;;ACTA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA,UAAU,+HAAmC;AAC7C,YAAY;AACZ,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;;AAEjB;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,uDAAuD,6DAA6D,oCAAoC;AACxJ;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,cAAI;AAC3B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,CAAC,gBAAK;AAC7B;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;ACpOA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9IA,+BAAmE,eAAuB,GAAG,CAAO;;;;;;;;;;;;;;;;;ACApG;;;;;6BAKiE,eAAuB,GAAG,CAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLrF;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,uBAAuB,GAAG,uBAAuB,GAAG,qBAAqB,GAAG,gBAAgB,GAAG,cAAc,GAAG,cAAc,GAAG,0BAA0B,GAAG,iBAAiB,GAAG,WAAW;AAC7L,eAAe,mBAAO,CAAC,kBAAM;AAC7B,iBAAiB,mBAAO,CAAC,yDAAU;AACnC,YAAY,mBAAO,CAAC,mDAAO;AAC3B,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,cAAc;AACd;AACA,YAAY,mBAAO,CAAC,mDAAO;AAC3B,0CAAyC;AACzC;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,4CAA2C;AAC3C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,iDAAgD;AAChD;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,mDAAkD;AAClD;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,mDAAkD;AAClD;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,aAAa,mBAAO,CAAC,mEAAkB;AACvC,aAAa,mBAAO,CAAC,qEAAmB;AACxC,aAAa,mBAAO,CAAC,+DAAgB;AACrC,aAAa,mBAAO,CAAC,iEAAiB;AACtC;AACA,aAAa,mBAAO,CAAC,yDAAU;AAC/B,aAAa,mBAAO,CAAC,+EAAwB;;;;;;;;;;;AC/GhC;;AAEb;AACA;AACA;AACA,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,eAAe,mBAAO,CAAC,kBAAM;AAC7B;AACA,YAAY,mBAAO,CAAC,8DAAgB;AACpC;;;;;;;;;;;ACXa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;;;;;AClBL;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;;;;;;;;;;;ACJW;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,sBAAsB;AACtB,YAAY,mBAAO,CAAC,2DAAY;AAChC,oBAAoB,mBAAO,CAAC,6DAAa;AACzC,qBAAqB,mBAAO,CAAC,+DAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA,wDAAwD,KAAK;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB;;;;;;;;;;;ACrRT;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,mBAAmB,GAAG,kBAAkB,GAAG,gBAAgB;AAC3D,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,mBAAmB,mBAAO,CAAC,2DAAY;AACvC,eAAe,mBAAO,CAAC,kBAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;ACnNN;;AAEb,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,iBAAiB,mBAAO,CAAC,uDAAU;AACnC,YAAY,mBAAO,CAAC,2DAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;AC/Ga;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,iBAAiB;AACjB,mBAAmB,mBAAO,CAAC,2DAAY;AACvC,mBAAmB,mBAAO,CAAC,2DAAY;AACvC,eAAe,mBAAO,CAAC,kBAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACnIJ;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,cAAc,GAAG,iBAAiB;AAClC,YAAY,mBAAO,CAAC,oDAAQ;AAC5B,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,wBAAwB,mBAAO,CAAC,wEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;ACpRD;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,oBAAoB;AACpB,YAAY,mBAAO,CAAC,oDAAQ;AAC5B,eAAe,mBAAO,CAAC,kBAAM;AAC7B,aAAa,mBAAO,CAAC,cAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,qCAAqC,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,oDAAoD,MAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,+CAA+C,MAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,yDAAyD,MAAM;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,0CAA0C,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,2CAA2C,MAAM;AACjD,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,iDAAiD,MAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;ACrZpB;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;UCrBA;;;;;;;;;ACDA,MAAM;EAAEA,GAAG;EAAEC,aAAa;EAAEC;AAAQ,CAAC,GAAGC,mBAAO,CAAC,0BAAU,CAAC;AAC3D,MAAMC,IAAI,GAAGD,mBAAO,CAAC,kBAAM,CAAC;AAC5B,MAAME,EAAE,GAAGF,mBAAO,CAAC,cAAI,CAAC;AACxB,MAAMG,GAAG,GAAGH,mBAAO,CAAC,6CAAK,CAAC;AAG1B,IAAIA,mBAAO,CAAC,oFAA2B,CAAC,EAAE;EACxCH,GAAG,CAACO,IAAI,CAAC,CAAC;AACZ;AAEA,MAAMC,MAAM,GAAG,IAAIF,GAAG,CAACG,MAAM,CAAC;EAC5BC,eAAe,EAAE;AACnB,CAAC,CAAC;AAEF,MAAMC,WAAW,GAAG,MAAAA,CAAA,KAAY;EAC9B,MAAMC,OAAO,GAAG,MAAMJ,MAAM,CAACK,UAAU,CAAC,CAAC;EACzC,MAAMC,IAAI,GAAGF,OAAO,CAACG,GAAG,CAACC,CAAC,IAAK,GAAEA,CAAC,CAACC,QAAS,KAAID,CAAC,CAACE,SAAU,KAAIF,CAAC,CAACG,YAAY,IAAI,aAAc,EAAC,CAAC;EAClGL,IAAI,CAACM,OAAO,CAAC,yDAAyD,CAAC;EAEvEC,OAAO,CAACC,OAAO,CAACC,GAAG,IAAI;IACrB,IAAIA,GAAG,EAAE;MACPA,GAAG,CAACC,WAAW,CAACC,IAAI,CAAC,SAAS,EAAEX,IAAI,CAACY,IAAI,CAAC,IAAI,CAAC,CAAC;IAClD;EACF,CAAC,CAAC;AACJ,CAAC;AAED,MAAMC,YAAY,GAAGA,CAAA,KAAM;EACzB;EACA,MAAMC,UAAU,GAAG,IAAI3B,aAAa,CAAC;IACnC4B,KAAK,EAAE,GAAG;IACVC,MAAM,EAAE,GAAG;IACXC,cAAc,EAAE;MACdC,OAAO,EAAEC,0FAAiC;MAC1CC,eAAe,EAAE;IACnB;EACF,CAAC,CAAC;;EAEF;EACAN,UAAU,CAACO,OAAO,CAACC,mCAAyB,CAAC;;EAE7C;EACAR,UAAU,CAACJ,WAAW,CAACa,YAAY,CAAC,CAAC;EACrC1B,WAAW,CAAC,CAAC;AACf,CAAC;AAEDX,GAAG,CAACsC,SAAS,CAAC,CAAC,CAACC,IAAI,CAAC,MAAM;EACzBZ,YAAY,CAAC,CAAC;EACdnB,MAAM,CAACgC,gBAAgB,CAAC,SAAS,EAAE7B,WAAW,CAAC;EAC/CH,MAAM,CAACgC,gBAAgB,CAAC,YAAY,EAAE7B,WAAW,CAAC;EAClDX,GAAG,CAACyC,EAAE,CAAC,UAAU,EAAE,MAAM;IACvB,IAAIxC,aAAa,CAACyC,aAAa,CAAC,CAAC,CAACC,MAAM,KAAK,CAAC,EAAE;MAC9ChB,YAAY,CAAC,CAAC;IAChB;EACF,CAAC,CAAC;;EAEF;EACA,MAAMiB,KAAK,GAAGvC,EAAE,CAACwC,WAAW,CAACC,SAAS,CAAC;EACvCC,OAAO,CAACC,GAAG,CAAC,qCAAqC,EAAEJ,KAAK,CAAC;AAC3D,CAAC,CAAC;AAEF5C,GAAG,CAACyC,EAAE,CAAC,mBAAmB,EAAE,MAAM;EAChCjC,MAAM,CAACyC,mBAAmB,CAAC,SAAS,EAAEtC,WAAW,CAAC;EAClDH,MAAM,CAACyC,mBAAmB,CAAC,YAAY,EAAEtC,WAAW,CAAC;EACrD,IAAIuC,OAAO,CAACC,QAAQ,KAAK,QAAQ,EAAE;IACjCnD,GAAG,CAACO,IAAI,CAAC,CAAC;EACZ;AACF,CAAC,CAAC,C","sources":["webpack://electron-with-react/./node_modules/electron-squirrel-startup/index.js","webpack://electron-with-react/./node_modules/electron-squirrel-startup/node_modules/debug/src/browser.js","webpack://electron-with-react/./node_modules/electron-squirrel-startup/node_modules/debug/src/debug.js","webpack://electron-with-react/./node_modules/electron-squirrel-startup/node_modules/debug/src/index.js","webpack://electron-with-react/./node_modules/electron-squirrel-startup/node_modules/debug/src/node.js","webpack://electron-with-react/./node_modules/electron-squirrel-startup/node_modules/ms/index.js","webpack://electron-with-react/./node_modules/node-gyp-build/index.js","webpack://electron-with-react/./node_modules/node-gyp-build/node-gyp-build.js","webpack://electron-with-react/./node_modules/usb/dist/index.js","webpack://electron-with-react/./node_modules/usb/dist/usb/bindings.js","webpack://electron-with-react/./node_modules/usb/dist/usb/capability.js","webpack://electron-with-react/./node_modules/usb/dist/usb/descriptors.js","webpack://electron-with-react/./node_modules/usb/dist/usb/device.js","webpack://electron-with-react/./node_modules/usb/dist/usb/endpoint.js","webpack://electron-with-react/./node_modules/usb/dist/usb/index.js","webpack://electron-with-react/./node_modules/usb/dist/usb/interface.js","webpack://electron-with-react/./node_modules/usb/dist/webusb/index.js","webpack://electron-with-react/./node_modules/usb/dist/webusb/webusb-device.js","webpack://electron-with-react/external node-commonjs \"child_process\"","webpack://electron-with-react/external node-commonjs \"electron\"","webpack://electron-with-react/external node-commonjs \"events\"","webpack://electron-with-react/external node-commonjs \"fs\"","webpack://electron-with-react/external node-commonjs \"net\"","webpack://electron-with-react/external node-commonjs \"os\"","webpack://electron-with-react/external node-commonjs \"path\"","webpack://electron-with-react/external node-commonjs \"tty\"","webpack://electron-with-react/external node-commonjs \"util\"","webpack://electron-with-react/webpack/bootstrap","webpack://electron-with-react/webpack/runtime/compat","webpack://electron-with-react/./src/main.js"],"sourcesContent":["var path = require('path');\nvar spawn = require('child_process').spawn;\nvar debug = require('debug')('electron-squirrel-startup');\nvar app = require('electron').app;\nvar run = function (args, done) {\n  var updateExe = path.resolve(path.dirname(process.execPath), '..', 'Update.exe');\n  debug('Spawning `%s` with args `%s`', updateExe, args);\n  spawn(updateExe, args, {\n    detached: true\n  }).on('close', done);\n};\nvar check = function () {\n  if (process.platform === 'win32') {\n    var cmd = process.argv[1];\n    debug('processing squirrel command `%s`', cmd);\n    var target = path.basename(process.execPath);\n    if (cmd === '--squirrel-install' || cmd === '--squirrel-updated') {\n      run(['--createShortcut=' + target + ''], app.quit);\n      return true;\n    }\n    if (cmd === '--squirrel-uninstall') {\n      run(['--removeShortcut=' + target + ''], app.quit);\n      return true;\n    }\n    if (cmd === '--squirrel-obsolete') {\n      app.quit();\n      return true;\n    }\n  }\n  return false;\n};\nmodule.exports = check();","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||\n  // is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||\n  // is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||\n  // double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\n  if (!useColors) return;\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit');\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch (e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch (e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}","/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0,\n    i;\n  for (i in namespace) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    args[0] = exports.coerce(args[0]);\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n  exports.names = [];\n  exports.skips = [];\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}","/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {\n    return k.toUpperCase();\n  });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();\n}\nvar stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts).split('\\n').map(function (str) {\n    return str.trim();\n  }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream(fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n    case 'FILE':\n      var fs = require('fs');\n      stream = new fs.SyncWriteStream(fd, {\n        autoClose: false\n      });\n      stream._type = 'fs';\n      break;\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n  stream._isStdio = true;\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n  debug.inspectOpts = {};\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}",null,null,"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LibUSBException = exports.useUsbDkBackend = exports.getDeviceList = exports.Transfer = exports.Device = exports.webusb = exports.findBySerialNumber = exports.findByIds = exports.usb = void 0;\nconst util_1 = require(\"util\");\nconst webusb_1 = require(\"./webusb\");\nconst usb = require(\"./usb\");\nexports.usb = usb;\n/**\n * Convenience method to get the first device with the specified VID and PID, or `undefined` if no such device is present.\n * @param vid\n * @param pid\n */\nconst findByIds = (vid, pid) => {\n  const devices = usb.getDeviceList();\n  return devices.find(item => item.deviceDescriptor.idVendor === vid && item.deviceDescriptor.idProduct === pid);\n};\nexports.findByIds = findByIds;\n/**\n * Convenience method to get the device with the specified serial number, or `undefined` if no such device is present.\n * @param serialNumber\n */\nconst findBySerialNumber = async serialNumber => {\n  const devices = usb.getDeviceList();\n  const opened = device => !!device.interfaces;\n  for (const device of devices) {\n    try {\n      if (!opened(device)) {\n        device.open();\n      }\n      const getStringDescriptor = (0, util_1.promisify)(device.getStringDescriptor).bind(device);\n      const buffer = await getStringDescriptor(device.deviceDescriptor.iSerialNumber);\n      if (buffer && buffer.toString() === serialNumber) {\n        return device;\n      }\n    } catch {\n      // Ignore any errors, device may be a system device or inaccessible\n    } finally {\n      try {\n        if (opened(device)) {\n          device.close();\n        }\n      } catch {\n        // Ignore any errors, device may be a system device or inaccessible\n      }\n    }\n  }\n  return undefined;\n};\nexports.findBySerialNumber = findBySerialNumber;\nconst webusb = new webusb_1.WebUSB();\nexports.webusb = webusb;\n// Usb types\nvar usb_1 = require(\"./usb\");\nObject.defineProperty(exports, \"Device\", {\n  enumerable: true,\n  get: function () {\n    return usb_1.Device;\n  }\n});\nObject.defineProperty(exports, \"Transfer\", {\n  enumerable: true,\n  get: function () {\n    return usb_1.Transfer;\n  }\n});\nObject.defineProperty(exports, \"getDeviceList\", {\n  enumerable: true,\n  get: function () {\n    return usb_1.getDeviceList;\n  }\n});\nObject.defineProperty(exports, \"useUsbDkBackend\", {\n  enumerable: true,\n  get: function () {\n    return usb_1.useUsbDkBackend;\n  }\n});\nObject.defineProperty(exports, \"LibUSBException\", {\n  enumerable: true,\n  get: function () {\n    return usb_1.LibUSBException;\n  }\n});\n__exportStar(require(\"./usb/capability\"), exports);\n__exportStar(require(\"./usb/descriptors\"), exports);\n__exportStar(require(\"./usb/endpoint\"), exports);\n__exportStar(require(\"./usb/interface\"), exports);\n// WebUSB types\n__exportStar(require(\"./webusb\"), exports);\n__exportStar(require(\"./webusb/webusb-device\"), exports);","\"use strict\";\n\n// Definitions from DefinitelyTyped, thanks to:\n//  Eric Brody <https://github.com/underscorebrody>\n//  Rob Moran <https://github.com/thegecko>\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst path_1 = require(\"path\");\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst usb = require('node-gyp-build')((0, path_1.join)(__dirname, '..', '..'));\nmodule.exports = usb;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Capability = void 0;\nclass Capability {\n  constructor(device, id) {\n    this.device = device;\n    this.id = id;\n    if (!device._bosDescriptor) {\n      throw new Error('bosDescriptor not found');\n    }\n    this.descriptor = device._bosDescriptor.capabilities[this.id];\n    this.type = this.descriptor.bDevCapabilityType;\n    this.data = this.descriptor.dev_capability_data;\n  }\n}\nexports.Capability = Capability;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtendedDevice = void 0;\nconst usb = require(\"./bindings\");\nconst interface_1 = require(\"./interface\");\nconst capability_1 = require(\"./capability\");\nconst isBuffer = obj => !!obj && obj instanceof Uint8Array;\nconst DEFAULT_TIMEOUT = 1000;\nclass ExtendedDevice {\n  constructor() {\n    this._timeout = DEFAULT_TIMEOUT;\n  }\n  /**\n   * Timeout in milliseconds to use for control transfers.\n   */\n  get timeout() {\n    return this._timeout || DEFAULT_TIMEOUT;\n  }\n  set timeout(value) {\n    this._timeout = value;\n  }\n  /**\n   * Object with properties for the fields of the active configuration descriptor.\n   */\n  get configDescriptor() {\n    try {\n      return this.__getConfigDescriptor();\n    } catch (e) {\n      // Check descriptor exists\n      if (e.errno === usb.LIBUSB_ERROR_NOT_FOUND) {\n        return undefined;\n      }\n      throw e;\n    }\n  }\n  /**\n   * Contains all config descriptors of the device (same structure as .configDescriptor above)\n   */\n  get allConfigDescriptors() {\n    try {\n      return this.__getAllConfigDescriptors();\n    } catch (e) {\n      // Check descriptors exist\n      if (e.errno === usb.LIBUSB_ERROR_NOT_FOUND) {\n        return [];\n      }\n      throw e;\n    }\n  }\n  /**\n   * Contains the parent of the device, such as a hub. If there is no parent this property is set to `null`.\n   */\n  get parent() {\n    return this.__getParent();\n  }\n  /**\n   * Open the device.\n   * @param defaultConfig\n   */\n  open(defaultConfig = true) {\n    this.__open();\n    // The presence of interfaces is used to determine if the device is open\n    this.interfaces = [];\n    if (defaultConfig === false) {\n      return;\n    }\n    const len = this.configDescriptor ? this.configDescriptor.interfaces.length : 0;\n    for (let i = 0; i < len; i++) {\n      this.interfaces[i] = new interface_1.Interface(this, i);\n    }\n  }\n  /**\n   * Close the device.\n   *\n   * The device must be open to use this method.\n   */\n  close() {\n    this.__close();\n    this.interfaces = undefined;\n  }\n  /**\n   * Set the device configuration to something other than the default (0). To use this, first call `.open(false)` (which tells it not to auto configure),\n   * then before claiming an interface, call this method.\n   *\n   * The device must be open to use this method.\n   * @param desired\n   * @param callback\n   */\n  setConfiguration(desired, callback) {\n    this.__setConfiguration(desired, error => {\n      if (!error) {\n        this.interfaces = [];\n        const len = this.configDescriptor ? this.configDescriptor.interfaces.length : 0;\n        for (let i = 0; i < len; i++) {\n          this.interfaces[i] = new interface_1.Interface(this, i);\n        }\n      }\n      if (callback) {\n        callback.call(this, error);\n      }\n    });\n  }\n  /**\n   * Perform a control transfer with `libusb_control_transfer`.\n   *\n   * Parameter `data_or_length` can be an integer length for an IN transfer, or a `Buffer` for an OUT transfer. The type must match the direction specified in the MSB of bmRequestType.\n   *\n   * The `data` parameter of the callback is actual transferred for OUT transfers, or will be passed a Buffer for IN transfers.\n   *\n   * The device must be open to use this method.\n   * @param bmRequestType\n   * @param bRequest\n   * @param wValue\n   * @param wIndex\n   * @param data_or_length\n   * @param callback\n   */\n  controlTransfer(bmRequestType, bRequest, wValue, wIndex, data_or_length, callback) {\n    const isIn = !!(bmRequestType & usb.LIBUSB_ENDPOINT_IN);\n    const wLength = isIn ? data_or_length : data_or_length.length;\n    if (isIn) {\n      if (wLength < 0) {\n        throw new TypeError('Expected size number for IN transfer (based on bmRequestType)');\n      }\n    } else {\n      if (!isBuffer(data_or_length)) {\n        throw new TypeError('Expected buffer for OUT transfer (based on bmRequestType)');\n      }\n    }\n    // Buffer for the setup packet\n    // http://libusbx.sourceforge.net/api-1.0/structlibusb__control__setup.html\n    const buf = Buffer.alloc(wLength + usb.LIBUSB_CONTROL_SETUP_SIZE);\n    buf.writeUInt8(bmRequestType, 0);\n    buf.writeUInt8(bRequest, 1);\n    buf.writeUInt16LE(wValue, 2);\n    buf.writeUInt16LE(wIndex, 4);\n    buf.writeUInt16LE(wLength, 6);\n    if (!isIn) {\n      buf.set(data_or_length, usb.LIBUSB_CONTROL_SETUP_SIZE);\n    }\n    const transfer = new usb.Transfer(this, 0, usb.LIBUSB_TRANSFER_TYPE_CONTROL, this.timeout, (error, buf, actual) => {\n      if (callback) {\n        if (isIn) {\n          callback.call(this, error, buf.slice(usb.LIBUSB_CONTROL_SETUP_SIZE, usb.LIBUSB_CONTROL_SETUP_SIZE + actual));\n        } else {\n          callback.call(this, error, actual);\n        }\n      }\n    });\n    try {\n      transfer.submit(buf);\n    } catch (e) {\n      if (callback) {\n        process.nextTick(() => callback.call(this, e, undefined));\n      }\n    }\n    return this;\n  }\n  /**\n   * Return the interface with the specified interface number.\n   *\n   * The device must be open to use this method.\n   * @param addr\n   */\n  interface(addr) {\n    if (!this.interfaces) {\n      throw new Error('Device must be open before searching for interfaces');\n    }\n    addr = addr || 0;\n    for (let i = 0; i < this.interfaces.length; i++) {\n      if (this.interfaces[i].interfaceNumber === addr) {\n        return this.interfaces[i];\n      }\n    }\n    throw new Error(`Interface not found for address: ${addr}`);\n  }\n  /**\n   * Perform a control transfer to retrieve a string descriptor\n   *\n   * The device must be open to use this method.\n   * @param desc_index\n   * @param callback\n   */\n  getStringDescriptor(desc_index, callback) {\n    // Index 0 indicates null\n    if (desc_index === 0) {\n      callback();\n      return;\n    }\n    const langid = 0x0409;\n    const length = 255;\n    this.controlTransfer(usb.LIBUSB_ENDPOINT_IN, usb.LIBUSB_REQUEST_GET_DESCRIPTOR, usb.LIBUSB_DT_STRING << 8 | desc_index, langid, length, (error, buffer) => {\n      if (error) {\n        return callback(error);\n      }\n      callback(undefined, isBuffer(buffer) ? buffer.toString('utf16le', 2) : undefined);\n    });\n  }\n  /**\n   * Perform a control transfer to retrieve an object with properties for the fields of the Binary Object Store descriptor.\n   *\n   * The device must be open to use this method.\n   * @param callback\n   */\n  getBosDescriptor(callback) {\n    if (this._bosDescriptor) {\n      // Cached descriptor\n      return callback(undefined, this._bosDescriptor);\n    }\n    if (this.deviceDescriptor.bcdUSB < 0x201) {\n      // BOS is only supported from USB 2.0.1\n      return callback(undefined, undefined);\n    }\n    this.controlTransfer(usb.LIBUSB_ENDPOINT_IN, usb.LIBUSB_REQUEST_GET_DESCRIPTOR, usb.LIBUSB_DT_BOS << 8, 0, usb.LIBUSB_DT_BOS_SIZE, (error, buffer) => {\n      if (error) {\n        // Check BOS descriptor exists\n        if (error.errno === usb.LIBUSB_TRANSFER_STALL) return callback(undefined, undefined);\n        return callback(error, undefined);\n      }\n      if (!isBuffer(buffer)) {\n        return callback(undefined, undefined);\n      }\n      const totalLength = buffer.readUInt16LE(2);\n      this.controlTransfer(usb.LIBUSB_ENDPOINT_IN, usb.LIBUSB_REQUEST_GET_DESCRIPTOR, usb.LIBUSB_DT_BOS << 8, 0, totalLength, (error, buffer) => {\n        if (error) {\n          // Check BOS descriptor exists\n          if (error.errno === usb.LIBUSB_TRANSFER_STALL) return callback(undefined, undefined);\n          return callback(error, undefined);\n        }\n        if (!isBuffer(buffer)) {\n          return callback(undefined, undefined);\n        }\n        const descriptor = {\n          bLength: buffer.readUInt8(0),\n          bDescriptorType: buffer.readUInt8(1),\n          wTotalLength: buffer.readUInt16LE(2),\n          bNumDeviceCaps: buffer.readUInt8(4),\n          capabilities: []\n        };\n        let i = usb.LIBUSB_DT_BOS_SIZE;\n        while (i < descriptor.wTotalLength) {\n          const capability = {\n            bLength: buffer.readUInt8(i + 0),\n            bDescriptorType: buffer.readUInt8(i + 1),\n            bDevCapabilityType: buffer.readUInt8(i + 2),\n            dev_capability_data: buffer.slice(i + 3, i + buffer.readUInt8(i + 0))\n          };\n          descriptor.capabilities.push(capability);\n          i += capability.bLength;\n        }\n        // Cache descriptor\n        this._bosDescriptor = descriptor;\n        callback(undefined, this._bosDescriptor);\n      });\n    });\n  }\n  /**\n   * Retrieve a list of Capability objects for the Binary Object Store capabilities of the device.\n   *\n   * The device must be open to use this method.\n   * @param callback\n   */\n  getCapabilities(callback) {\n    const capabilities = [];\n    this.getBosDescriptor((error, descriptor) => {\n      if (error) return callback(error, undefined);\n      const len = descriptor ? descriptor.capabilities.length : 0;\n      for (let i = 0; i < len; i++) {\n        capabilities.push(new capability_1.Capability(this, i));\n      }\n      callback(undefined, capabilities);\n    });\n  }\n}\nexports.ExtendedDevice = ExtendedDevice;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OutEndpoint = exports.InEndpoint = exports.Endpoint = void 0;\nconst events_1 = require(\"events\");\nconst bindings_1 = require(\"./bindings\");\nconst util_1 = require(\"util\");\nconst isBuffer = obj => obj && obj instanceof Uint8Array;\n/** Common base for InEndpoint and OutEndpoint. */\nclass Endpoint extends events_1.EventEmitter {\n  constructor(device, descriptor) {\n    super();\n    this.device = device;\n    /** Sets the timeout in milliseconds for transfers on this endpoint. The default, `0`, is infinite timeout. */\n    this.timeout = 0;\n    this.descriptor = descriptor;\n    this.address = descriptor.bEndpointAddress;\n    this.transferType = descriptor.bmAttributes & 0x03;\n  }\n  /** Clear the halt/stall condition for this endpoint. */\n  clearHalt(callback) {\n    return this.device.__clearHalt(this.address, callback);\n  }\n  /**\n   * Create a new `Transfer` object for this endpoint.\n   *\n   * The passed callback will be called when the transfer is submitted and finishes. Its arguments are the error (if any), the submitted buffer, and the amount of data actually written (for\n   * OUT transfers) or read (for IN transfers).\n   *\n   * @param timeout Timeout for the transfer (0 means unlimited).\n   * @param callback Transfer completion callback.\n   */\n  makeTransfer(timeout, callback) {\n    return new bindings_1.Transfer(this.device, this.address, this.transferType, timeout, callback);\n  }\n}\nexports.Endpoint = Endpoint;\n/** Endpoints in the IN direction (device->PC) have this type. */\nclass InEndpoint extends Endpoint {\n  constructor(device, descriptor) {\n    super(device, descriptor);\n    /** Endpoint direction. */\n    this.direction = 'in';\n    this.pollTransfers = [];\n    this.pollTransferSize = 0;\n    this.pollPending = 0;\n    this.pollActive = false;\n    this.transferAsync = (0, util_1.promisify)(this.transfer).bind(this);\n  }\n  /**\n   * Perform a transfer to read data from the endpoint.\n   *\n   * If length is greater than maxPacketSize, libusb will automatically split the transfer in multiple packets, and you will receive one callback with all data once all packets are complete.\n   *\n   * `this` in the callback is the InEndpoint object.\n   *\n   * The device must be open to use this method.\n   * @param length\n   * @param callback\n   */\n  transfer(length, callback) {\n    const buffer = Buffer.alloc(length);\n    const cb = (error, _buffer, actualLength) => {\n      callback.call(this, error, buffer.slice(0, actualLength));\n    };\n    try {\n      this.makeTransfer(this.timeout, cb).submit(buffer);\n    } catch (e) {\n      process.nextTick(() => callback.call(this, e));\n    }\n    return this;\n  }\n  /**\n   * Start polling the endpoint.\n   *\n   * The library will keep `nTransfers` transfers of size `transferSize` pending in the kernel at all times to ensure continuous data flow.\n   * This is handled by the libusb event thread, so it continues even if the Node v8 thread is busy. The `data` and `error` events are emitted as transfers complete.\n   *\n   * The device must be open to use this method.\n   * @param nTransfers\n   * @param transferSize\n   * @param callback\n   */\n  startPoll(nTransfers, transferSize, callback) {\n    const transferDone = (error, transfer, buffer, actualLength) => {\n      if (!error) {\n        this.emit('data', buffer.slice(0, actualLength));\n      } else if (error.errno !== bindings_1.LIBUSB_TRANSFER_CANCELLED) {\n        if (this.pollActive) {\n          this.emit('error', error);\n          this.stopPoll();\n        }\n      }\n      if (this.pollActive) {\n        startTransfer(transfer);\n      } else {\n        this.pollPending--;\n        if (this.pollPending === 0) {\n          this.pollTransfers = [];\n          this.pollActive = false;\n          this.emit('end');\n          if (callback) {\n            const cancelled = (error === null || error === void 0 ? void 0 : error.errno) === bindings_1.LIBUSB_TRANSFER_CANCELLED;\n            callback(cancelled ? undefined : error, buffer, actualLength, cancelled);\n          }\n        }\n      }\n    };\n    const startTransfer = transfer => {\n      try {\n        transfer.submit(Buffer.alloc(this.pollTransferSize), (error, buffer, actualLength) => {\n          transferDone(error, transfer, buffer, actualLength);\n        });\n      } catch (e) {\n        this.emit('error', e);\n        this.stopPoll();\n      }\n    };\n    this.pollTransfers = this.startPollTransfers(nTransfers, transferSize, function (error, buffer, actualLength) {\n      transferDone(error, this, buffer, actualLength);\n    });\n    this.pollTransfers.forEach(startTransfer);\n    this.pollPending = this.pollTransfers.length;\n    return this.pollTransfers;\n  }\n  startPollTransfers(nTransfers = 3, transferSize = this.descriptor.wMaxPacketSize, callback) {\n    if (this.pollActive) {\n      throw new Error('Polling already active');\n    }\n    this.pollTransferSize = transferSize;\n    this.pollActive = true;\n    this.pollPending = 0;\n    const transfers = [];\n    for (let i = 0; i < nTransfers; i++) {\n      const transfer = this.makeTransfer(0, callback);\n      transfers[i] = transfer;\n    }\n    return transfers;\n  }\n  /**\n   * Stop polling.\n   *\n   * Further data may still be received. The `end` event is emitted and the callback is called once all transfers have completed or canceled.\n   *\n   * The device must be open to use this method.\n   * @param callback\n   */\n  stopPoll(callback) {\n    if (!this.pollActive) {\n      throw new Error('Polling is not active.');\n    }\n    for (let i = 0; i < this.pollTransfers.length; i++) {\n      try {\n        this.pollTransfers[i].cancel();\n      } catch (error) {\n        this.emit('error', error);\n      }\n    }\n    this.pollActive = false;\n    if (callback) this.once('end', callback);\n  }\n}\nexports.InEndpoint = InEndpoint;\n/** Endpoints in the OUT direction (PC->device) have this type. */\nclass OutEndpoint extends Endpoint {\n  constructor(device, descriptor) {\n    super(device, descriptor);\n    /** Endpoint direction. */\n    this.direction = 'out';\n    this.transferAsync = (0, util_1.promisify)(this.transfer).bind(this);\n  }\n  /**\n   * Perform a transfer to write `data` to the endpoint.\n   *\n   * If length is greater than maxPacketSize, libusb will automatically split the transfer in multiple packets, and you will receive one callback once all packets are complete.\n   *\n   * `this` in the callback is the OutEndpoint object.\n   *\n   * The device must be open to use this method.\n   * @param buffer\n   * @param callback\n   */\n  transfer(buffer, callback) {\n    if (!buffer) {\n      buffer = Buffer.alloc(0);\n    } else if (!isBuffer(buffer)) {\n      buffer = Buffer.from(buffer);\n    }\n    const cb = (error, _buffer, actual) => {\n      if (callback) {\n        callback.call(this, error, actual || 0);\n      }\n    };\n    try {\n      this.makeTransfer(this.timeout, cb).submit(buffer);\n    } catch (e) {\n      process.nextTick(() => cb(e));\n    }\n    return this;\n  }\n  transferWithZLP(buffer, callback) {\n    if (buffer.length % this.descriptor.wMaxPacketSize === 0) {\n      this.transfer(buffer);\n      this.transfer(Buffer.alloc(0), callback);\n    } else {\n      this.transfer(buffer, callback);\n    }\n  }\n}\nexports.OutEndpoint = OutEndpoint;","\"use strict\";\n\nconst events_1 = require(\"events\");\nconst device_1 = require(\"./device\");\nconst usb = require(\"./bindings\");\nif (usb.INIT_ERROR) {\n  /* eslint-disable no-console */\n  console.warn('Failed to initialize libusb.');\n}\nObject.setPrototypeOf(usb, events_1.EventEmitter.prototype);\nObject.defineProperty(usb, 'pollHotplug', {\n  value: false,\n  writable: true\n});\nObject.defineProperty(usb, 'pollHotplugDelay', {\n  value: 500,\n  writable: true\n});\n// `usb.Device` is not defined when `usb.INIT_ERROR` is true\nif (usb.Device) {\n  Object.getOwnPropertyNames(device_1.ExtendedDevice.prototype).forEach(name => {\n    Object.defineProperty(usb.Device.prototype, name, Object.getOwnPropertyDescriptor(device_1.ExtendedDevice.prototype, name) || Object.create(null));\n  });\n}\n// Devices delta support for non-libusb hotplug events\nlet hotPlugDevices = new Set();\n// This method needs to be used for attach/detach IDs (hotplugSupportType === 2) rather than a lookup because vid/pid are not unique\nconst emitHotplugEvents = () => {\n  // Collect current devices\n  const devices = new Set(usb.getDeviceList());\n  // Find attached devices\n  for (const device of devices) {\n    if (!hotPlugDevices.has(device)) {\n      usb.emit('attach', device);\n    }\n  }\n  // Find detached devices\n  for (const device of hotPlugDevices) {\n    if (!devices.has(device)) {\n      usb.emit('detach', device);\n    }\n  }\n  hotPlugDevices = devices;\n};\n// Polling mechanism for checking device changes where hotplug detection is not available\nlet pollingHotplug = false;\nconst pollHotplug = (start = false) => {\n  if (start) {\n    pollingHotplug = true;\n  } else if (!pollingHotplug) {\n    return;\n  } else {\n    emitHotplugEvents();\n  }\n  setTimeout(() => pollHotplug(), usb.pollHotplugDelay);\n};\n// Devices changed event handler\nconst devicesChanged = () => setTimeout(() => emitHotplugEvents(), usb.pollHotplugDelay);\n// Hotplug control\nlet hotplugSupported = 0;\nconst startHotplug = () => {\n  hotplugSupported = usb.pollHotplug ? 0 : usb._supportedHotplugEvents();\n  if (hotplugSupported !== 1) {\n    // Collect initial devices when not using libusb\n    hotPlugDevices = new Set(usb.getDeviceList());\n  }\n  if (hotplugSupported) {\n    // Use hotplug event emitters\n    usb._enableHotplugEvents();\n    if (hotplugSupported === 2) {\n      // Use hotplug ID events to trigger a change check\n      usb.on('attachIds', devicesChanged);\n      usb.on('detachIds', devicesChanged);\n    }\n  } else {\n    // Fallback to using polling to check for changes\n    pollHotplug(true);\n  }\n};\nconst stopHotplug = () => {\n  if (hotplugSupported) {\n    // Disable hotplug events\n    usb._disableHotplugEvents();\n    if (hotplugSupported === 2) {\n      // Remove hotplug ID event listeners\n      usb.off('attachIds', devicesChanged);\n      usb.off('detachIds', devicesChanged);\n    }\n  } else {\n    // Stop polling\n    pollingHotplug = false;\n  }\n};\nusb.on('newListener', event => {\n  if (event !== 'attach' && event !== 'detach') {\n    return;\n  }\n  const listenerCount = usb.listenerCount('attach') + usb.listenerCount('detach');\n  if (listenerCount === 0) {\n    startHotplug();\n  }\n});\nusb.on('removeListener', event => {\n  if (event !== 'attach' && event !== 'detach') {\n    return;\n  }\n  const listenerCount = usb.listenerCount('attach') + usb.listenerCount('detach');\n  if (listenerCount === 0) {\n    stopHotplug();\n  }\n});\nmodule.exports = usb;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interface = void 0;\nconst bindings_1 = require(\"./bindings\");\nconst endpoint_1 = require(\"./endpoint\");\nconst util_1 = require(\"util\");\nclass Interface {\n  constructor(device, id) {\n    this.device = device;\n    this.id = id;\n    /** Integer alternate setting number. */\n    this.altSetting = 0;\n    this.refresh();\n    this.releaseAsync = (0, util_1.promisify)(this.release).bind(this);\n    this.setAltSettingAsync = (0, util_1.promisify)(this.setAltSetting).bind(this);\n  }\n  refresh() {\n    if (!this.device.configDescriptor) {\n      return;\n    }\n    this.descriptor = this.device.configDescriptor.interfaces[this.id][this.altSetting];\n    this.interfaceNumber = this.descriptor.bInterfaceNumber;\n    this.endpoints = [];\n    const len = this.descriptor.endpoints.length;\n    for (let i = 0; i < len; i++) {\n      const desc = this.descriptor.endpoints[i];\n      const c = desc.bEndpointAddress & bindings_1.LIBUSB_ENDPOINT_IN ? endpoint_1.InEndpoint : endpoint_1.OutEndpoint;\n      this.endpoints[i] = new c(this.device, desc);\n    }\n  }\n  /**\n   * Claims the interface. This method must be called before using any endpoints of this interface.\n   *\n   * The device must be open to use this method.\n   */\n  claim() {\n    this.device.__claimInterface(this.id);\n  }\n  release(closeEndpointsOrCallback, callback) {\n    let closeEndpoints = false;\n    if (typeof closeEndpointsOrCallback === 'boolean') {\n      closeEndpoints = closeEndpointsOrCallback;\n    } else {\n      callback = closeEndpointsOrCallback;\n    }\n    const next = () => {\n      this.device.__releaseInterface(this.id, error => {\n        if (!error) {\n          this.altSetting = 0;\n          this.refresh();\n        }\n        if (callback) {\n          callback.call(this, error);\n        }\n      });\n    };\n    if (!closeEndpoints || this.endpoints.length === 0) {\n      next();\n    } else {\n      let n = this.endpoints.length;\n      this.endpoints.forEach(ep => {\n        if (ep.direction === 'in' && ep.pollActive) {\n          ep.once('end', () => {\n            if (--n === 0) {\n              next();\n            }\n          });\n          ep.stopPoll();\n        } else {\n          if (--n === 0) {\n            next();\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Returns `false` if a kernel driver is not active; `true` if active.\n   *\n   * The device must be open to use this method.\n   */\n  isKernelDriverActive() {\n    return this.device.__isKernelDriverActive(this.id);\n  }\n  /**\n   * Detaches the kernel driver from the interface.\n   *\n   * The device must be open to use this method.\n   */\n  detachKernelDriver() {\n    return this.device.__detachKernelDriver(this.id);\n  }\n  /**\n   * Re-attaches the kernel driver for the interface.\n   *\n   * The device must be open to use this method.\n   */\n  attachKernelDriver() {\n    return this.device.__attachKernelDriver(this.id);\n  }\n  /**\n   * Sets the alternate setting. It updates the `interface.endpoints` array to reflect the endpoints found in the alternate setting.\n   *\n   * The device must be open to use this method.\n   * @param altSetting\n   * @param callback\n   */\n  setAltSetting(altSetting, callback) {\n    this.device.__setInterface(this.id, altSetting, error => {\n      if (!error) {\n        this.altSetting = altSetting;\n        this.refresh();\n      }\n      if (callback) {\n        callback.call(this, error);\n      }\n    });\n  }\n  /**\n   * Return the InEndpoint or OutEndpoint with the specified address.\n   *\n   * The device must be open to use this method.\n   * @param addr\n   */\n  endpoint(addr) {\n    return this.endpoints.find(item => item.address === addr);\n  }\n}\nexports.Interface = Interface;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebUSB = exports.getWebUsb = void 0;\nconst usb = require(\"../usb\");\nconst events_1 = require(\"events\");\nconst webusb_device_1 = require(\"./webusb-device\");\n/**\n * Convenience method to get the WebUSB interface available\n */\nconst getWebUsb = () => {\n  if (navigator && navigator.usb) {\n    return navigator.usb;\n  }\n  return new WebUSB();\n};\nexports.getWebUsb = getWebUsb;\nclass NamedError extends Error {\n  constructor(message, name) {\n    super(message);\n    this.name = name;\n  }\n}\nclass WebUSB {\n  constructor(options = {}) {\n    this.options = options;\n    this.emitter = new events_1.EventEmitter();\n    this.knownDevices = new Map();\n    this.authorisedDevices = new Set();\n    const deviceConnectCallback = async device => {\n      const webDevice = await this.getWebDevice(device);\n      // When connected, emit an event if it is an allowed device\n      if (webDevice && this.isAuthorisedDevice(webDevice)) {\n        const event = {\n          type: 'connect',\n          device: webDevice\n        };\n        this.emitter.emit('connect', event);\n      }\n    };\n    const deviceDisconnectCallback = async device => {\n      // When disconnected, emit an event if the device was a known allowed device\n      if (this.knownDevices.has(device)) {\n        const webDevice = this.knownDevices.get(device);\n        if (webDevice && this.isAuthorisedDevice(webDevice)) {\n          const event = {\n            type: 'disconnect',\n            device: webDevice\n          };\n          this.emitter.emit('disconnect', event);\n        }\n      }\n    };\n    this.emitter.on('newListener', event => {\n      const listenerCount = this.emitter.listenerCount(event);\n      if (listenerCount !== 0) {\n        return;\n      }\n      if (event === 'connect') {\n        usb.addListener('attach', deviceConnectCallback);\n      } else if (event === 'disconnect') {\n        usb.addListener('detach', deviceDisconnectCallback);\n      }\n    });\n    this.emitter.on('removeListener', event => {\n      const listenerCount = this.emitter.listenerCount(event);\n      if (listenerCount !== 0) {\n        return;\n      }\n      if (event === 'connect') {\n        usb.removeListener('attach', deviceConnectCallback);\n      } else if (event === 'disconnect') {\n        usb.removeListener('detach', deviceDisconnectCallback);\n      }\n    });\n  }\n  set onconnect(fn) {\n    if (this._onconnect) {\n      this.removeEventListener('connect', this._onconnect);\n      this._onconnect = undefined;\n    }\n    if (fn) {\n      this._onconnect = fn;\n      this.addEventListener('connect', this._onconnect);\n    }\n  }\n  set ondisconnect(fn) {\n    if (this._ondisconnect) {\n      this.removeEventListener('disconnect', this._ondisconnect);\n      this._ondisconnect = undefined;\n    }\n    if (fn) {\n      this._ondisconnect = fn;\n      this.addEventListener('disconnect', this._ondisconnect);\n    }\n  }\n  addEventListener(type, listener) {\n    this.emitter.addListener(type, listener);\n  }\n  removeEventListener(type, callback) {\n    this.emitter.removeListener(type, callback);\n  }\n  dispatchEvent(_event) {\n    // Don't dispatch from here\n    return false;\n  }\n  /**\n   * Requests a single Web USB device\n   * @param options The options to use when scanning\n   * @returns Promise containing the selected device\n   */\n  async requestDevice(options) {\n    // Must have options\n    if (!options) {\n      throw new TypeError('requestDevice error: 1 argument required, but only 0 present');\n    }\n    // Options must be an object\n    if (options.constructor !== {}.constructor) {\n      throw new TypeError('requestDevice error: parameter 1 (options) is not an object');\n    }\n    // Must have a filter\n    if (!options.filters) {\n      throw new TypeError('requestDevice error: required member filters is undefined');\n    }\n    // Filter must be an array\n    if (options.filters.constructor !== [].constructor) {\n      throw new TypeError('requestDevice error: the provided value cannot be converted to a sequence');\n    }\n    // Check filters\n    options.filters.forEach(filter => {\n      // Protocol & Subclass\n      if (filter.protocolCode && !filter.subclassCode) {\n        throw new TypeError('requestDevice error: subclass code is required');\n      }\n      // Subclass & Class\n      if (filter.subclassCode && !filter.classCode) {\n        throw new TypeError('requestDevice error: class code is required');\n      }\n    });\n    let devices = await this.loadDevices(options.filters);\n    devices = devices.filter(device => this.filterDevice(device, options.filters));\n    if (devices.length === 0) {\n      throw new NamedError('Failed to execute \\'requestDevice\\' on \\'USB\\': No device selected.', 'NotFoundError');\n    }\n    try {\n      // If no devicesFound function, select the first device found\n      const device = this.options.devicesFound ? await this.options.devicesFound(devices) : devices[0];\n      if (!device) {\n        throw new NamedError('Failed to execute \\'requestDevice\\' on \\'USB\\': No device selected.', 'NotFoundError');\n      }\n      this.authorisedDevices.add({\n        vendorId: device.vendorId,\n        productId: device.productId,\n        classCode: device.deviceClass,\n        subclassCode: device.deviceSubclass,\n        protocolCode: device.deviceProtocol,\n        serialNumber: device.serialNumber\n      });\n      return device;\n    } catch (error) {\n      throw new NamedError('Failed to execute \\'requestDevice\\' on \\'USB\\': No device selected.', 'NotFoundError');\n    }\n  }\n  /**\n   * Gets all allowed Web USB devices which are connected\n   * @returns Promise containing an array of devices\n   */\n  async getDevices() {\n    const preFilters = this.options.allowAllDevices ? undefined : this.options.allowedDevices;\n    // Refresh devices and filter for allowed ones\n    const devices = await this.loadDevices(preFilters);\n    return devices.filter(device => this.isAuthorisedDevice(device));\n  }\n  async loadDevices(preFilters) {\n    let devices = usb.getDeviceList();\n    // Pre-filter devices\n    devices = this.quickFilter(devices, preFilters);\n    const refreshedKnownDevices = new Map();\n    for (const device of devices) {\n      const webDevice = await this.getWebDevice(device);\n      if (webDevice) {\n        refreshedKnownDevices.set(device, webDevice);\n      }\n    }\n    // Refresh knownDevices to remove old devices from the map\n    this.knownDevices = refreshedKnownDevices;\n    return [...this.knownDevices.values()];\n  }\n  // Get a WebUSBDevice corresponding to underlying device.\n  // Returns undefined the device was not found and could not be created.\n  async getWebDevice(device) {\n    if (!this.knownDevices.has(device)) {\n      if (this.options.deviceTimeout) {\n        device.timeout = this.options.deviceTimeout;\n      }\n      try {\n        const webDevice = await webusb_device_1.WebUSBDevice.createInstance(device);\n        this.knownDevices.set(device, webDevice);\n      } catch {\n        // Ignore creation issues as this may be a system device\n      }\n    }\n    return this.knownDevices.get(device);\n  }\n  // Undertake quick filter on devices before creating WebUSB devices if possible\n  quickFilter(devices, preFilters) {\n    if (!preFilters || !preFilters.length) {\n      return devices;\n    }\n    // Just pre-filter on vid/pid\n    return devices.filter(device => preFilters.some(filter => {\n      // Vendor\n      if (filter.vendorId && filter.vendorId !== device.deviceDescriptor.idVendor) return false;\n      // Product\n      if (filter.productId && filter.productId !== device.deviceDescriptor.idProduct) return false;\n      // Ignore Class, Subclass and Protocol as these need to check interfaces, too\n      // Ignore serial number for node-usb as it requires device connection\n      return true;\n    }));\n  }\n  // Filter WebUSB devices\n  filterDevice(device, filters) {\n    if (!filters || !filters.length) {\n      return true;\n    }\n    return filters.some(filter => {\n      // Vendor\n      if (filter.vendorId && filter.vendorId !== device.vendorId) return false;\n      // Product\n      if (filter.productId && filter.productId !== device.productId) return false;\n      // Class\n      if (filter.classCode) {\n        if (!device.configuration) {\n          return false;\n        }\n        // Interface Descriptors\n        const match = device.configuration.interfaces.some(iface => {\n          // Class\n          if (filter.classCode && filter.classCode !== iface.alternate.interfaceClass) return false;\n          // Subclass\n          if (filter.subclassCode && filter.subclassCode !== iface.alternate.interfaceSubclass) return false;\n          // Protocol\n          if (filter.protocolCode && filter.protocolCode !== iface.alternate.interfaceProtocol) return false;\n          return true;\n        });\n        if (match) {\n          return true;\n        }\n      }\n      // Class\n      if (filter.classCode && filter.classCode !== device.deviceClass) return false;\n      // Subclass\n      if (filter.subclassCode && filter.subclassCode !== device.deviceSubclass) return false;\n      // Protocol\n      if (filter.protocolCode && filter.protocolCode !== device.deviceProtocol) return false;\n      // Serial\n      if (filter.serialNumber && filter.serialNumber !== device.serialNumber) return false;\n      return true;\n    });\n  }\n  // Check whether a device is authorised\n  isAuthorisedDevice(device) {\n    // All devices are authorised\n    if (this.options.allowAllDevices) {\n      return true;\n    }\n    // Check any allowed device filters\n    if (this.options.allowedDevices && this.filterDevice(device, this.options.allowedDevices)) {\n      return true;\n    }\n    // Check authorised devices\n    return [...this.authorisedDevices.values()].some(authorised => authorised.vendorId === device.vendorId && authorised.productId === device.productId && authorised.classCode === device.deviceClass && authorised.subclassCode === device.deviceSubclass && authorised.protocolCode === device.deviceProtocol && authorised.serialNumber === device.serialNumber);\n  }\n}\nexports.WebUSB = WebUSB;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebUSBDevice = void 0;\nconst usb = require(\"../usb\");\nconst util_1 = require(\"util\");\nconst os_1 = require(\"os\");\nconst LIBUSB_TRANSFER_TYPE_MASK = 0x03;\nconst ENDPOINT_NUMBER_MASK = 0x7f;\nconst CLEAR_FEATURE = 0x01;\nconst ENDPOINT_HALT = 0x00;\n/**\n * Wrapper to make a node-usb device look like a webusb device\n */\nclass WebUSBDevice {\n  static async createInstance(device) {\n    const instance = new WebUSBDevice(device);\n    await instance.initialize();\n    return instance;\n  }\n  constructor(device) {\n    this.device = device;\n    this.configurations = [];\n    const usbVersion = this.decodeVersion(device.deviceDescriptor.bcdUSB);\n    this.usbVersionMajor = usbVersion.major;\n    this.usbVersionMinor = usbVersion.minor;\n    this.usbVersionSubminor = usbVersion.sub;\n    this.deviceClass = device.deviceDescriptor.bDeviceClass;\n    this.deviceSubclass = device.deviceDescriptor.bDeviceSubClass;\n    this.deviceProtocol = device.deviceDescriptor.bDeviceProtocol;\n    this.vendorId = device.deviceDescriptor.idVendor;\n    this.productId = device.deviceDescriptor.idProduct;\n    const deviceVersion = this.decodeVersion(device.deviceDescriptor.bcdDevice);\n    this.deviceVersionMajor = deviceVersion.major;\n    this.deviceVersionMinor = deviceVersion.minor;\n    this.deviceVersionSubminor = deviceVersion.sub;\n    this.controlTransferAsync = (0, util_1.promisify)(this.device.controlTransfer).bind(this.device);\n    this.setConfigurationAsync = (0, util_1.promisify)(this.device.setConfiguration).bind(this.device);\n    this.resetAsync = (0, util_1.promisify)(this.device.reset).bind(this.device);\n    this.getStringDescriptorAsync = (0, util_1.promisify)(this.device.getStringDescriptor).bind(this.device);\n  }\n  get configuration() {\n    if (!this.device.configDescriptor) {\n      return undefined;\n    }\n    const currentConfiguration = this.device.configDescriptor.bConfigurationValue;\n    return this.configurations.find(configuration => configuration.configurationValue === currentConfiguration);\n  }\n  get opened() {\n    return !!this.device.interfaces;\n  }\n  async open() {\n    try {\n      if (this.opened) {\n        return;\n      }\n      this.device.open();\n    } catch (error) {\n      throw new Error(`open error: ${error}`);\n    }\n  }\n  async close() {\n    try {\n      if (!this.opened) {\n        return;\n      }\n      try {\n        if (this.configuration) {\n          for (const iface of this.configuration.interfaces) {\n            await this._releaseInterface(iface.interfaceNumber);\n            // Re-create the USBInterface to set the claimed attribute\n            this.configuration.interfaces[this.configuration.interfaces.indexOf(iface)] = {\n              interfaceNumber: iface.interfaceNumber,\n              alternate: iface.alternate,\n              alternates: iface.alternates,\n              claimed: false\n            };\n          }\n        }\n      } catch (_error) {\n        // Ignore\n      }\n      this.device.close();\n    } catch (error) {\n      throw new Error(`close error: ${error}`);\n    }\n  }\n  async selectConfiguration(configurationValue) {\n    if (!this.opened || !this.device.configDescriptor) {\n      throw new Error('selectConfiguration error: invalid state');\n    }\n    if (this.device.configDescriptor.bConfigurationValue === configurationValue) {\n      return;\n    }\n    const config = this.configurations.find(configuration => configuration.configurationValue === configurationValue);\n    if (!config) {\n      throw new Error('selectConfiguration error: configuration not found');\n    }\n    try {\n      await this.setConfigurationAsync(configurationValue);\n    } catch (error) {\n      throw new Error(`selectConfiguration error: ${error}`);\n    }\n  }\n  async claimInterface(interfaceNumber) {\n    if (!this.opened) {\n      throw new Error('claimInterface error: invalid state');\n    }\n    if (!this.configuration) {\n      throw new Error('claimInterface error: interface not found');\n    }\n    const iface = this.configuration.interfaces.find(usbInterface => usbInterface.interfaceNumber === interfaceNumber);\n    if (!iface) {\n      throw new Error('claimInterface error: interface not found');\n    }\n    if (iface.claimed) {\n      return;\n    }\n    try {\n      this.device.interface(interfaceNumber).claim();\n      // Re-create the USBInterface to set the claimed attribute\n      this.configuration.interfaces[this.configuration.interfaces.indexOf(iface)] = {\n        interfaceNumber,\n        alternate: iface.alternate,\n        alternates: iface.alternates,\n        claimed: true\n      };\n    } catch (error) {\n      throw new Error(`claimInterface error: ${error}`);\n    }\n  }\n  async releaseInterface(interfaceNumber) {\n    await this._releaseInterface(interfaceNumber);\n    if (this.configuration) {\n      const iface = this.configuration.interfaces.find(usbInterface => usbInterface.interfaceNumber === interfaceNumber);\n      if (iface) {\n        // Re-create the USBInterface to set the claimed attribute\n        this.configuration.interfaces[this.configuration.interfaces.indexOf(iface)] = {\n          interfaceNumber,\n          alternate: iface.alternate,\n          alternates: iface.alternates,\n          claimed: false\n        };\n      }\n    }\n  }\n  async selectAlternateInterface(interfaceNumber, alternateSetting) {\n    if (!this.opened) {\n      throw new Error('selectAlternateInterface error: invalid state');\n    }\n    if (!this.configuration) {\n      throw new Error('selectAlternateInterface error: interface not found');\n    }\n    const iface = this.configuration.interfaces.find(usbInterface => usbInterface.interfaceNumber === interfaceNumber);\n    if (!iface) {\n      throw new Error('selectAlternateInterface error: interface not found');\n    }\n    if (!iface.claimed) {\n      throw new Error('selectAlternateInterface error: invalid state');\n    }\n    try {\n      const iface = this.device.interface(interfaceNumber);\n      await iface.setAltSettingAsync(alternateSetting);\n    } catch (error) {\n      throw new Error(`selectAlternateInterface error: ${error}`);\n    }\n  }\n  async controlTransferIn(setup, length) {\n    try {\n      this.checkDeviceOpen();\n      const type = this.controlTransferParamsToType(setup, usb.LIBUSB_ENDPOINT_IN);\n      const result = await this.controlTransferAsync(type, setup.request, setup.value, setup.index, length);\n      return {\n        data: result ? new DataView(new Uint8Array(result).buffer) : undefined,\n        status: 'ok'\n      };\n    } catch (error) {\n      if (error.errno === usb.LIBUSB_TRANSFER_STALL) {\n        return {\n          status: 'stall'\n        };\n      }\n      if (error.errno === usb.LIBUSB_TRANSFER_OVERFLOW) {\n        return {\n          status: 'babble'\n        };\n      }\n      throw new Error(`controlTransferIn error: ${error}`);\n    }\n  }\n  async controlTransferOut(setup, data) {\n    try {\n      this.checkDeviceOpen();\n      const type = this.controlTransferParamsToType(setup, usb.LIBUSB_ENDPOINT_OUT);\n      const buffer = data ? Buffer.from(data) : Buffer.alloc(0);\n      const bytesWritten = await this.controlTransferAsync(type, setup.request, setup.value, setup.index, buffer);\n      return {\n        bytesWritten,\n        status: 'ok'\n      };\n    } catch (error) {\n      if (error.errno === usb.LIBUSB_TRANSFER_STALL) {\n        return {\n          bytesWritten: 0,\n          status: 'stall'\n        };\n      }\n      throw new Error(`controlTransferOut error: ${error}`);\n    }\n  }\n  async clearHalt(direction, endpointNumber) {\n    try {\n      const wIndex = endpointNumber | (direction === 'in' ? usb.LIBUSB_ENDPOINT_IN : usb.LIBUSB_ENDPOINT_OUT);\n      await this.controlTransferAsync(usb.LIBUSB_RECIPIENT_ENDPOINT, CLEAR_FEATURE, ENDPOINT_HALT, wIndex, Buffer.from(new Uint8Array()));\n    } catch (error) {\n      throw new Error(`clearHalt error: ${error}`);\n    }\n  }\n  async transferIn(endpointNumber, length) {\n    try {\n      this.checkDeviceOpen();\n      const endpoint = this.getEndpoint(endpointNumber | usb.LIBUSB_ENDPOINT_IN);\n      const result = await endpoint.transferAsync(length);\n      return {\n        data: result ? new DataView(new Uint8Array(result).buffer) : undefined,\n        status: 'ok'\n      };\n    } catch (error) {\n      if (error.errno === usb.LIBUSB_TRANSFER_STALL) {\n        return {\n          status: 'stall'\n        };\n      }\n      if (error.errno === usb.LIBUSB_TRANSFER_OVERFLOW) {\n        return {\n          status: 'babble'\n        };\n      }\n      throw new Error(`transferIn error: ${error}`);\n    }\n  }\n  async transferOut(endpointNumber, data) {\n    try {\n      this.checkDeviceOpen();\n      const endpoint = this.getEndpoint(endpointNumber | usb.LIBUSB_ENDPOINT_OUT);\n      const buffer = Buffer.from(data);\n      const bytesWritten = await endpoint.transferAsync(buffer);\n      return {\n        bytesWritten,\n        status: 'ok'\n      };\n    } catch (error) {\n      if (error.errno === usb.LIBUSB_TRANSFER_STALL) {\n        return {\n          bytesWritten: 0,\n          status: 'stall'\n        };\n      }\n      throw new Error(`transferOut error: ${error}`);\n    }\n  }\n  async reset() {\n    try {\n      await this.resetAsync();\n    } catch (error) {\n      throw new Error(`reset error: ${error}`);\n    }\n  }\n  async isochronousTransferIn(_endpointNumber, _packetLengths) {\n    throw new Error('isochronousTransferIn error: method not implemented');\n  }\n  async isochronousTransferOut(_endpointNumber, _data, _packetLengths) {\n    throw new Error('isochronousTransferOut error: method not implemented');\n  }\n  async forget() {\n    throw new Error('forget error: method not implemented');\n  }\n  async initialize() {\n    try {\n      if (!this.opened) {\n        this.device.open();\n        // Explicitly set configuration for vendor-specific devices on macos\n        // https://github.com/node-usb/node-usb/issues/61\n        if (this.deviceClass === 0xff && (0, os_1.platform)() === 'darwin') {\n          await this.setConfigurationAsync(1);\n        }\n      }\n      this.manufacturerName = await this.getStringDescriptor(this.device.deviceDescriptor.iManufacturer);\n      this.productName = await this.getStringDescriptor(this.device.deviceDescriptor.iProduct);\n      this.serialNumber = await this.getStringDescriptor(this.device.deviceDescriptor.iSerialNumber);\n      this.configurations = await this.getConfigurations();\n    } catch (error) {\n      throw new Error(`initialize error: ${error}`);\n    } finally {\n      if (this.opened) {\n        this.device.close();\n      }\n    }\n  }\n  decodeVersion(version) {\n    const hex = `0000${version.toString(16)}`.slice(-4);\n    return {\n      major: parseInt(hex.substr(0, 2), undefined),\n      minor: parseInt(hex.substr(2, 1), undefined),\n      sub: parseInt(hex.substr(3, 1), undefined)\n    };\n  }\n  async getStringDescriptor(index) {\n    try {\n      const buffer = await this.getStringDescriptorAsync(index);\n      return buffer ? buffer.toString() : '';\n    } catch (error) {\n      return '';\n    }\n  }\n  async getConfigurations() {\n    const configs = [];\n    for (const config of this.device.allConfigDescriptors) {\n      const interfaces = [];\n      for (const iface of config.interfaces) {\n        const alternates = [];\n        for (const alternate of iface) {\n          const endpoints = [];\n          for (const endpoint of alternate.endpoints) {\n            endpoints.push({\n              endpointNumber: endpoint.bEndpointAddress & ENDPOINT_NUMBER_MASK,\n              direction: endpoint.bEndpointAddress & usb.LIBUSB_ENDPOINT_IN ? 'in' : 'out',\n              type: (endpoint.bmAttributes & LIBUSB_TRANSFER_TYPE_MASK) === usb.LIBUSB_TRANSFER_TYPE_BULK ? 'bulk' : (endpoint.bmAttributes & LIBUSB_TRANSFER_TYPE_MASK) === usb.LIBUSB_TRANSFER_TYPE_INTERRUPT ? 'interrupt' : 'isochronous',\n              packetSize: endpoint.wMaxPacketSize\n            });\n          }\n          alternates.push({\n            alternateSetting: alternate.bAlternateSetting,\n            interfaceClass: alternate.bInterfaceClass,\n            interfaceSubclass: alternate.bInterfaceSubClass,\n            interfaceProtocol: alternate.bInterfaceProtocol,\n            interfaceName: await this.getStringDescriptor(alternate.iInterface),\n            endpoints\n          });\n        }\n        const interfaceNumber = iface[0].bInterfaceNumber;\n        const alternate = alternates.find(alt => alt.alternateSetting === this.device.interface(interfaceNumber).altSetting);\n        if (alternate) {\n          interfaces.push({\n            interfaceNumber,\n            alternate,\n            alternates,\n            claimed: false\n          });\n        }\n      }\n      configs.push({\n        configurationValue: config.bConfigurationValue,\n        configurationName: await this.getStringDescriptor(config.iConfiguration),\n        interfaces\n      });\n    }\n    return configs;\n  }\n  getEndpoint(address) {\n    if (!this.device.interfaces) {\n      return undefined;\n    }\n    for (const iface of this.device.interfaces) {\n      const endpoint = iface.endpoint(address);\n      if (endpoint) {\n        return endpoint;\n      }\n    }\n    return undefined;\n  }\n  controlTransferParamsToType(setup, direction) {\n    const recipient = setup.recipient === 'device' ? usb.LIBUSB_RECIPIENT_DEVICE : setup.recipient === 'interface' ? usb.LIBUSB_RECIPIENT_INTERFACE : setup.recipient === 'endpoint' ? usb.LIBUSB_RECIPIENT_ENDPOINT : usb.LIBUSB_RECIPIENT_OTHER;\n    const requestType = setup.requestType === 'standard' ? usb.LIBUSB_REQUEST_TYPE_STANDARD : setup.requestType === 'class' ? usb.LIBUSB_REQUEST_TYPE_CLASS : usb.LIBUSB_REQUEST_TYPE_VENDOR;\n    return recipient | requestType | direction;\n  }\n  async _releaseInterface(interfaceNumber) {\n    if (!this.opened) {\n      throw new Error('releaseInterface error: invalid state');\n    }\n    if (!this.configuration) {\n      throw new Error('releaseInterface error: interface not found');\n    }\n    const iface = this.configuration.interfaces.find(usbInterface => usbInterface.interfaceNumber === interfaceNumber);\n    if (!iface) {\n      throw new Error('releaseInterface error: interface not found');\n    }\n    if (!iface.claimed) {\n      return;\n    }\n    try {\n      const iface = this.device.interface(interfaceNumber);\n      await iface.releaseAsync();\n    } catch (error) {\n      throw new Error(`releaseInterface error: ${error}`);\n    }\n  }\n  checkDeviceOpen() {\n    if (!this.opened) {\n      throw new Error('The device must be opened first');\n    }\n  }\n}\nexports.WebUSBDevice = WebUSBDevice;","module.exports = require(\"child_process\");","module.exports = require(\"electron\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"tty\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/native_modules/\";","const { app, BrowserWindow, ipcMain } = require(\"electron\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst usb = require('usb');\n\n\nif (require(\"electron-squirrel-startup\")) {\n  app.quit();\n}\n\nconst webusb = new usb.WebUSB({\n  allowAllDevices: true\n});\n\nconst showDevices = async () => {\n  const devices = await webusb.getDevices();\n  const text = devices.map(d => `${d.vendorId}\\t${d.productId}\\t${d.serialNumber || '<no serial>'}`);\n  text.unshift('VID\\tPID\\tSerial\\n-------------------------------------');\n\n  windows.forEach(win => {\n    if (win) {\n      win.webContents.send('devices', text.join('\\n'));\n    }\n  });\n};\n\nconst createWindow = () => {\n  // Create the browser window.\n  const mainWindow = new BrowserWindow({\n    width: 800,\n    height: 600,\n    webPreferences: {\n      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,\n      nodeIntegration: true,\n    },\n  });\n\n  // and load the index.html of the app.\n  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);\n\n  // Open the DevTools.\n  mainWindow.webContents.openDevTools();\n  showDevices();\n};\n\napp.whenReady().then(() => {\n  createWindow();\n  webusb.addEventListener('connect', showDevices);\n  webusb.addEventListener('disconnect', showDevices);\n  app.on(\"activate\", () => {\n    if (BrowserWindow.getAllWindows().length === 0) {\n      createWindow();\n    }\n  });\n\n  //    \n  const files = fs.readdirSync(__dirname);\n  console.log(\"    :\", files);\n});\n\napp.on(\"window-all-closed\", () => {\n  webusb.removeEventListener('connect', showDevices);\n  webusb.removeEventListener('disconnect', showDevices);\n  if (process.platform !== \"darwin\") {\n    app.quit();\n  }\n});\n"],"names":["app","BrowserWindow","ipcMain","require","path","fs","usb","quit","webusb","WebUSB","allowAllDevices","showDevices","devices","getDevices","text","map","d","vendorId","productId","serialNumber","unshift","windows","forEach","win","webContents","send","join","createWindow","mainWindow","width","height","webPreferences","preload","MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY","nodeIntegration","loadURL","MAIN_WINDOW_WEBPACK_ENTRY","openDevTools","whenReady","then","addEventListener","on","getAllWindows","length","files","readdirSync","__dirname","console","log","removeEventListener","process","platform"],"sourceRoot":""}